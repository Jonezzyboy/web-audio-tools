<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Sequencer</title>
  <link rel="stylesheet" href="theme.css">
  <style>
    /* VISUALIZER */
    canvas {
      width: 100%;
      height: 80px;
      background: #2d3436;
      border-radius: 6px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
    }

    /* CONTROLS */
    .global-controls {
      background: #f1f2f6;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .control-row label {
      font-size: 0.8rem;
      font-weight: 700;
      width: 70px;
    }

    .control-row input[type=range] {
      flex: 1;
      margin: 0 10px;
      cursor: pointer;
    }

    /* Granular numeric inputs */
    .num-input {
      width: 60px;
      padding: 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      text-align: right;
      font-family: monospace;
    }

    select.num-input {
      width: 80px;
    }

    /* SEQUENCER LIST */
    .sequence-list {
      margin-bottom: 20px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 6px;
      padding: 5px;
    }

    .tone-row {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #f1f2f6;
      transition: background 0.1s;
      border-radius: 4px;
    }

    /* The Timeline Highlight Class */
    .tone-row.is-playing {
      background-color: var(--playing);
      border-left: 4px solid #00b894;
      font-weight: bold;
    }

    .tone-row span {
      font-size: 0.8rem;
      width: 30px;
      color: #b2bec3;
      font-weight: bold;
    }

    .tone-row input {
      flex: 1;
      padding: 8px;
      border: 1px solid #dfe6e9;
      border-radius: 6px;
      font-size: 0.9rem;
      margin-right: 10px;
    }

    .tone-row button {
      background: transparent;
      color: var(--danger);
      border: 1px solid var(--danger);
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .tone-row button:hover {
      background: var(--danger);
      color: white;
    }

    /* ACTION AREA */
    .action-area {
      display: grid;
      gap: 10px;
    }

    .add-btn {
      width: 100%;
      padding: 10px;
      background: #fff;
      border: 2px dashed #b2bec3;
      color: #636e72;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .add-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: #f8f9fa;
    }

    /* Button row layout moved to theme.css for consistency */

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Tone Sequencer</h1>

  <canvas id="visualizer" width="500" height="100"></canvas>

  <div class="global-controls">
    <div class="control-row">
      <label>Speed (ms)</label>
      <input type="range" id="speedRange" min="50" max="1000" value="120">
      <input type="number" id="speedNum" class="num-input" value="120">
    </div>

    <div class="control-row">
      <label>Base (Hz)</label>
      <input type="range" id="freqRange" min="50" max="1000" value="440">
      <input type="number" id="freqNum" class="num-input" value="440">
    </div>

    <div class="control-row">
      <label>Decay</label>
      <input type="range" id="decayRange" min="1" max="10" step="0.1" value="2">
      <input type="number" id="decayNum" class="num-input" value="2" step="0.1">
    </div>

    <div class="control-row">
      <label>Wave</label>
      <select id="waveType" class="num-input">
        <option value="sine">Sine</option>
        <option value="square">Square</option>
        <option value="sawtooth">Saw</option>
        <option value="triangle">Tri</option>
      </select>
    </div>
  </div>

  <div id="sequenceContainer" class="sequence-list"></div>

  <div class="action-area">
    <button class="add-btn" id="addToneBtn">+ Add Tone Step</button>
    <div class="main-btns">
      <button class="btn-primary" id="playBtn">▶ Play</button>
      <button class="btn-primary btn-secondary" id="downloadBtn">⬇ WAV</button>
    </div>
  </div>
</div>

<script>
  // --- STATE ---
  let sequence = [1.0, 1.25, 1.5]; // Default Triad
  let audioCtx = null;
  let isPlaying = false;
  let animationId = null;
  let scheduledEvents = []; // For timeline tracking

  const els = {
    container: document.getElementById('sequenceContainer'),
    // Ranges
    speedR: document.getElementById('speedRange'),
    freqR:  document.getElementById('freqRange'),
    decayR: document.getElementById('decayRange'),
    // Numbers
    speedN: document.getElementById('speedNum'),
    freqN:  document.getElementById('freqNum'),
    decayN: document.getElementById('decayNum'),
    wave:   document.getElementById('waveType'),
    // Buttons
    addBtn:  document.getElementById('addToneBtn'),
    playBtn: document.getElementById('playBtn'),
    dlBtn:   document.getElementById('downloadBtn'),
    // Visuals
    canvas: document.getElementById('visualizer')
  };
  const canvasCtx = els.canvas.getContext('2d');

  // --- SYNC INPUTS (Granular Controls) ---
  function linkInputs(range, num)
  {
    range.addEventListener('input', () => num.value = range.value);
    num.addEventListener('input', () => range.value = num.value);
  }

  linkInputs(els.speedR, els.speedN);
  linkInputs(els.freqR, els.freqN);
  linkInputs(els.decayR, els.decayN);

  // --- UI RENDER ---
  function renderRows()
  {
    els.container.innerHTML = '';
    sequence.forEach((multiplier, index) =>
    {
      const row = document.createElement('div');
      row.className = 'tone-row';
      row.id = `row-${index}`; // Needed for timeline lookup

      const label = document.createElement('span');
      label.innerText = `#${index + 1}`;

      const input = document.createElement('input');
      input.type = 'number';
      input.step = '0.01';
      input.value = multiplier;
      input.onchange = (e) => sequence[index] = parseFloat(e.target.value);

      const delBtn = document.createElement('button');
      delBtn.innerText = '✕';
      delBtn.onclick = () =>
      {
        if(sequence.length > 1)
        {
          sequence.splice(index, 1);
          renderRows();
        }
      };
      if(sequence.length <= 1)
      {
        delBtn.disabled = true;
      }

      row.appendChild(label);
      row.appendChild(input);
      row.appendChild(delBtn);
      els.container.appendChild(row);
    });
  }

  els.addBtn.addEventListener('click', () =>
  {
    sequence.push(sequence[sequence.length - 1] || 1.0);
    renderRows();
  });

  // --- AUDIO & TIMELINE LOGIC ---

  // Generate Audio Graph
  function scheduleAudio(ctx, destination, startTime, isLivePlayback)
  {
    const baseFreq = parseFloat(els.freqN.value);
    const speedSeconds = parseFloat(els.speedN.value) / 1000;
    const decaySetting = parseFloat(els.decayN.value) * 0.1;
    const waveType = els.wave.value;

    scheduledEvents = []; // Reset timeline tracker

    // Master Gain for visualizer hookup
    const masterGain = ctx.createGain();
    masterGain.connect(destination);
    masterGain.gain.value = 0.5; // Avoid clipping

    let currentTime = startTime;

    sequence.forEach((multiplier, index) =>
    {
      const osc = ctx.createOscillator();
      const noteGain = ctx.createGain();

      osc.type = waveType;
      osc.frequency.setValueAtTime(baseFreq * multiplier, currentTime);

      // Envelope
      noteGain.gain.setValueAtTime(0, currentTime);
      noteGain.gain.linearRampToValueAtTime(1, currentTime + 0.01);
      noteGain.gain.exponentialRampToValueAtTime(0.001, currentTime + decaySetting + 0.1);

      osc.connect(noteGain);
      noteGain.connect(masterGain);

      const duration = decaySetting + 0.2;
      osc.start(currentTime);
      osc.stop(currentTime + duration);

      // Store timeline data
      if(isLivePlayback)
      {
        scheduledEvents.push({
          index: index,
          start: currentTime,
          end:   currentTime + speedSeconds
        });
      }

      currentTime += speedSeconds;
    });

    return {endTime: currentTime + 0.5, masterNode: masterGain};
  }

  // --- VISUALIZER & TIMELINE LOOP ---
  function startVisualizer(analyser)
  {
    analyser.fftSize = 2048;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    function draw()
    {
      if(!isPlaying)
      {
        return;
      }

      animationId = requestAnimationFrame(draw);

      // 1. Draw Waveform
      analyser.getByteTimeDomainData(dataArray);
      canvasCtx.fillStyle = 'rgb(45, 52, 54)';
      canvasCtx.fillRect(0, 0, els.canvas.width, els.canvas.height);
      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = 'rgb(85, 239, 196)'; // Neon Green
      canvasCtx.beginPath();

      const sliceWidth = els.canvas.width * 1.0 / bufferLength;
      let x = 0;

      for(let i = 0; i < bufferLength; i++)
      {
        const v = dataArray[i] / 128.0;
        const y = v * els.canvas.height / 2;
        if(i === 0)
        {
          canvasCtx.moveTo(x, y);
        }
        else
        {
          canvasCtx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      canvasCtx.lineTo(els.canvas.width, els.canvas.height / 2);
      canvasCtx.stroke();

      // 2. Update Timeline (Highlight Rows)
      const now = audioCtx.currentTime;

      // Clear all highlights
      document.querySelectorAll('.tone-row').forEach(r => r.classList.remove('is-playing'));

      // Find active note
      const activeEvent = scheduledEvents.find(e => now >= e.start && now < e.end);
      if(activeEvent)
      {
        const row = document.getElementById(`row-${activeEvent.index}`);
        if(row)
        {
          row.classList.add('is-playing');
          // Optional: Scroll to view
          row.scrollIntoView({behavior: 'smooth', block: 'nearest'});
        }
      }
    }

    draw();
  }

  // --- PLAYBACK ---
  els.playBtn.addEventListener('click', () =>
  {
    if(isPlaying)
    {
      return;
    } // Prevent double click

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    isPlaying = true;
    els.playBtn.disabled = true;

    // Create Analyser
    const analyser = audioCtx.createAnalyser();

    // Schedule Audio
    const {endTime, masterNode} = scheduleAudio(audioCtx, analyser, audioCtx.currentTime + 0.1, true);

    // Connect to speakers
    analyser.connect(audioCtx.destination);

    // Start Loops
    startVisualizer(analyser);

    // Cleanup when done
    const totalDuration = (endTime - audioCtx.currentTime) * 1000;
    setTimeout(() =>
    {
      isPlaying = false;
      els.playBtn.disabled = false;
      cancelAnimationFrame(animationId);
      // Clear final highlight
      document.querySelectorAll('.tone-row').forEach(r => r.classList.remove('is-playing'));
      audioCtx.close();
    }, totalDuration);
  });

  // --- DOWNLOAD ---
  els.dlBtn.addEventListener('click', async () =>
  {
    const originalText = els.dlBtn.innerText;
    els.dlBtn.innerText = 'Render...';

    const speedVal = parseFloat(els.speedN.value) / 1000;
    const duration = (sequence.length * speedVal) + 2.0;
    const sampleRate = 44100;

    const offlineCtx = new OfflineAudioContext(1, sampleRate * duration, sampleRate);

    scheduleAudio(offlineCtx, offlineCtx.destination, 0.1, false);

    const renderedBuffer = await offlineCtx.startRendering();
    const wavBytes = bufferToWave(renderedBuffer);
    const blob = new Blob([wavBytes], {type: 'audio/wav'});

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sequencer_output.wav';
    a.click();
    window.URL.revokeObjectURL(url);
    els.dlBtn.innerText = originalText;
  });

  // --- WAV ENCODER UTILITY ---
  function bufferToWave(abuffer)
  {
    let numOfChan = abuffer.numberOfChannels,
      length = abuffer.length * numOfChan * 2 + 44,
      buffer = new ArrayBuffer(length),
      view = new DataView(buffer),
      channels = [], i, sample,
      offset = 0, pos = 0;

    // Header
    setUint32(0x46464952); // "RIFF"
    setUint32(length - 8);
    setUint32(0x45564157); // "WAVE"
    setUint32(0x20746d66); // "fmt "
    setUint32(16);
    setUint16(1); // PCM
    setUint16(numOfChan);
    setUint32(abuffer.sampleRate);
    setUint32(abuffer.sampleRate * 2 * numOfChan);
    setUint16(numOfChan * 2);
    setUint16(16);
    setUint32(0x61746164); // "data"
    setUint32(length - pos - 4);

    for(i = 0; i < abuffer.numberOfChannels; i++)
    {
      channels.push(abuffer.getChannelData(i));
    }

    while(pos < length)
    {
      for(i = 0; i < numOfChan; i++)
      {
        let sampleVal = channels[i][offset] || 0;
        sample = Math.max(-1, Math.min(1, sampleVal));
        sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
        view.setInt16(pos, sample, true);
        pos += 2;
      }
      offset++;
    }
    return buffer;

    function setUint16(data)
    {
      view.setUint16(pos, data, true);
      pos += 2;
    }

    function setUint32(data)
    {
      view.setUint32(pos, data, true);
      pos += 4;
    }
  }

  // Init
  renderRows();
</script>
</body>
</html>